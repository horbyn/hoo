# Segment v.s. Section

参考资料：

- [《操作系统真象还原，郑钢》](https://book.douban.com/subject/26745156/)

个人理解是，两者都是指逻辑段。平时汇编源文件里说的代码 *"段"*，数据 *"段"* 等，都是指 `section`；而 `segment` 指的是链接之后的整个可执行文件内部的一个个逻辑段。类似以下：

```cpp
/*
 * 汇编文件1            汇编文件2
 * ┌────────────────┐   ┌────────────────┐
 * │section: .text1 │   │section: .text2 │
 * ├────────────────┤   ├────────────────┤
 * │section: .data1 │   │section: .data2 │
 * └────────────────┘   └────────────────┘
 *            \          /
 *             \ 链接   /
 *           ┌───────────────┐
 *           │segment: .text │
 *           ├───────────────┤
 *           │segment: .data │
 *           └───────────────┘
 */
```

如果你写过汇编，你可能知道汇编器会提供各种各样用来生成逻辑段的伪指令（`directive`），有的汇编器可能用的关键字是 `section`，有的可能是 `segment` 或者其他什么词。但这个只是汇编源文件层次上的事情，本质上只是方便程序员划分程序逻辑的 *"逻辑段"* 而已。**这种源文件上的逻辑段，一般用 `section` 来指代，中文常译为 `节`**。比如上面这个例子，汇编文件 1 和 2 都定义了逻辑段，因此广义上的 `section` 指的是 `.text1`、`.text2`、`.data1` 和 `.data2`

编译型语言从源文件走到可执行文件这个过程往往涉及多个阶段：源文件编译得到汇编文件，汇编文件汇编得到目标文件，最终将所有用到的目标文件链接到一起，就是可执行文件。可执行文件里面也有逻辑段，但这里的 *"逻辑"* 不是面向程序员的，而是面向加载器的。可执行文件包含的二进制数据可能是指令，可能是数据，也可能是有其他用途的东西。所以这里的 *"逻辑"* 指的是可读、可写、可执行，链接阶段负责将具有相同 *"逻辑"* 的节（`section`）合并起来。**这种可执行文件上的逻辑段，一般用 `segment` 来指代，中文常译为 `段`**。比如上面那个例子，链接完成后，得到了一个文件，里面的 `.text` 和 `.data` 就是广义上说的 `segment`。这个例子里 `.text` 由 `.text1` 和 `.text2` 合并而来，`.data` 同理（但是，也完全有可能和直观上不同，比如 `.text1` 和 `.data1` 合并，这是链接器负责的事，它的逻辑怎样的那需要研究链接器才行）

但也要注意，无论是 "节（`section`）" 还是 "段（`segment`）"，本质都是逻辑段，作区分只是为了强调是输入文件（汇编源文件）还是输出文件（目标文件）。实际上无论是输入文件还是输出文件，完全可以使用同一个术语，因为都是逻辑段。所以，具体语境具体分析

参考《真象还原》可以编译几个汇编文件来验证，但这里仅作记录：

> 可以使用 **readelf -e hello.elf** 来查看 `ELF` 头，输出信息分四部分，大概如下：
> ELF Header: 保存描述信息
> Section Header: 保存源文件逻辑段（即列举所有 `section`）
> Program Header: 保存可执行文件逻辑段（即列举所有 `segment`）
> Section to Segment mapping: 列举每个 `segment` 都由哪些 `section` 合并而成

<br></br>

# `.iplt` 这些是什么节

参考 [Re: Why gcc manual does not explain some sections](https://gcc.gnu.org/legacy-ml/gcc-help/2011-02/msg00172.html)

<br></br>
